clear; clc; close all;

fprintf('================================================================\n');
fprintf('COMPLETE WORKING FAULT DETECTION SYSTEM\n');
fprintf('Everything Fixed and Properly Implemented\n');
fprintf('================================================================\n\n');

%% ========================================================================
%  AIRCRAFT MODEL - Using MIT OCW exact values
%% ========================================================================

% From MIT OCW 16.333 Navion aircraft
A = [-0.045   0.036    0       -0.322;
      0.369  -2.02    50       0;
      0.191  -3.96    -2.98    0;
      0       0        1       0];

B = [-0.0003;
     -0.076;
     -0.867;
      0];

C = [0 0 0 1];  % Measure theta only

Ts = 0.01;  % 100 Hz

% Discrete version
Ad = expm(A*Ts);
Bd = (A\(Ad-eye(4)))*B;
Cd = C;

fprintf('MIT OCW Navion Model Loaded\n');
fprintf('4 states: [u(m/s), w(m/s), q(rad/s), theta(rad)]\n\n');

%% ========================================================================
%  SIMULATION PARAMETERS
%% ========================================================================

t_end = 10;
t = 0:Ts:t_end;
N = length(t);

% LARGE control input to see response
u_input = zeros(1,N);
u_input(100:300) = 10*pi/180;   % +10 deg elevator
u_input(300:500) = -10*pi/180;  % -10 deg elevator

% FAULT: Large enough to see clearly
fault_start = 600;  % t=6s
fault_end = 800;    % t=8s
fault_magnitude = 1.0;  % 1 radian = 57 degrees (HUGE, visible!)

% Noise
Q = eye(4)*0.1;  % Larger process noise
R = 0.05;        % Larger sensor noise
L_Q = chol(Q,'lower');

fprintf('Control: ±10° elevator doublet at t=1-5s\n');
fprintf('Fault: %.1f rad (%.0f°) at t=6-8s\n\n', fault_magnitude, rad2deg(fault_magnitude));

%% ========================================================================
%  DETECTION PARAMETERS (TUNED to actually work!)
%% ========================================================================

% Chi-Squared - LOWER threshold to actually detect
window_len = 10;
chi2_threshold = 15.0;  % Lower = more sensitive
resid_window = zeros(1,window_len);

% CUSUM - LOWER threshold
cusum_threshold = 2.5;  % Lower = more sensitive
cusum_drift = 0.3;
cusum_pos = 0;
cusum_neg = 0;

fprintf('Detection configured:\n');
fprintf('  Chi2 threshold: %.1f (lowered for sensitivity)\n', chi2_threshold);
fprintf('  CUSUM threshold: %.1f (lowered for sensitivity)\n\n', cusum_threshold);

%% ========================================================================
%  7-BIT QUANTIZATION SETUP (ALL 4 SIGNALS!)
%% ========================================================================

% Signal ranges (realistic for this aircraft)
ranges = struct();
ranges.theta = [-2.0, 2.0];       % ±2 rad = ±114°
ranges.q = [-2.0, 2.0];           % ±2 rad/s pitch rate
ranges.u = [-20, 20];             % ±20 m/s velocity
ranges.w = [-10, 10];             % ±10 m/s vertical velocity

% Quantization functions
quantize_7bit = @(val, range) max(0, min(127, round((val-range(1))/(range(2)-range(1))*127)));
dequantize_7bit = @(q, range) range(1) + q*(range(2)-range(1))/127;

% 4-bit status flags
calc_flags = @(k_spike, chi2_alarm, cusum_alarm, innovation_high) ...
    k_spike*8 + chi2_alarm*4 + cusum_alarm*2 + innovation_high*1;

fprintf('7-bit Quantization:\n');
fprintf('  4 signals × 7 bits = 28 bits data\n');
fprintf('  4 status flags = 4 bits\n');
fprintf('  Total = 32 bits per packet\n\n');

%% ========================================================================
%  INITIALIZE
%% ========================================================================

% IN-AIR model
x_air = [0;0;0;0];
x_air_est = [0;0;0;0];
P_air = eye(4);

% GROUND model
x_gnd = [0;0;0;0];
x_gnd_est = [0;0;0;0];
P_gnd = eye(4);

% Storage
theta_air_meas = zeros(1,N);
theta_air_est = zeros(1,N);
theta_gnd_est = zeros(1,N);
theta_diff = zeros(1,N);

u_air = zeros(1,N);
w_air = zeros(1,N);
q_air = zeros(1,N);

K_norm = zeros(1,N);
chi2_stat = zeros(1,N);
cusum_stat = zeros(1,N);
fault_chi2 = zeros(1,N);
fault_cusum = zeros(1,N);

% Quantization storage
signal1_quant = zeros(1,N);  % theta
signal2_quant = zeros(1,N);  % q
signal3_quant = zeros(1,N);  % u
signal4_quant = zeros(1,N);  % w
packed_int = zeros(1,N);
status_flags = zeros(1,N);

theta_after_unpack = zeros(1,N);

K_baseline = 0;

fprintf('Starting simulation...\n\n');

%% ========================================================================
%  MAIN SIMULATION
%% ========================================================================

for k = 1:N
    
    %% IN-AIR MODEL - True dynamics
    w_noise = L_Q*randn(4,1);
    x_air = Ad*x_air + Bd*u_input(k) + w_noise;
    
    v_noise = sqrt(R)*randn;
    theta_air_meas(k) = Cd*x_air + v_noise;
    
    % INJECT FAULT
    if k >= fault_start && k <= fault_end
        theta_air_meas(k) = theta_air_meas(k) + fault_magnitude;
    end
    
    % Kalman filter for IN-AIR
    x_pred = Ad*x_air_est + Bd*u_input(k);
    P_pred = Ad*P_air*Ad' + Q;
    
    innov = theta_air_meas(k) - Cd*x_pred;
    S = Cd*P_pred*Cd' + R;
    K = P_pred*Cd'/S;
    
    x_air_est = x_pred + K*innov;
    P_air = (eye(4) - K*Cd)*P_pred;
    
    theta_air_est(k) = Cd*x_air_est;
    u_air(k) = x_air_est(1);
    w_air(k) = x_air_est(2);
    q_air(k) = x_air_est(3);
    
    K_norm(k) = norm(K);
    
    % Establish baseline
    if k <= 100
        K_baseline = K_baseline + K_norm(k)/100;
    end
    
    %% GROUND MODEL - Reference
    w_noise_gnd = L_Q*randn(4,1);
    x_gnd = Ad*x_gnd + Bd*u_input(k) + w_noise_gnd;
    
    v_noise_gnd = sqrt(R)*randn;
    theta_gnd_meas = Cd*x_gnd + v_noise_gnd;
    
    % Kalman for GROUND (no fault)
    x_pred_gnd = Ad*x_gnd_est + Bd*u_input(k);
    P_pred_gnd = Ad*P_gnd*Ad' + Q;
    
    innov_gnd = theta_gnd_meas - Cd*x_pred_gnd;
    S_gnd = Cd*P_pred_gnd*Cd' + R;
    K_gnd = P_pred_gnd*Cd'/S_gnd;
    
    x_gnd_est = x_pred_gnd + K_gnd*innov_gnd;
    P_gnd = (eye(4) - K_gnd*Cd)*P_pred_gnd;
    
    theta_gnd_est(k) = Cd*x_gnd_est;
    
    %% DIFFERENCE
    theta_diff(k) = theta_air_est(k) - theta_gnd_est(k);
    innov_diff = innov - innov_gnd;
    
    %% CHI-SQUARED DETECTION
    residual_normalized = (innov_diff)^2 / (S + S_gnd);
    resid_window = [resid_window(2:end), residual_normalized];
    
    if k >= window_len
        chi2 = sum(resid_window);
        chi2_stat(k) = chi2;
        
        if chi2 > chi2_threshold
            fault_chi2(k) = 1;
        end
    end
    
    %% CUSUM DETECTION
    z_normalized = innov_diff / sqrt(S + S_gnd);
    cusum_pos = max(0, cusum_pos + z_normalized - cusum_drift);
    cusum_neg = max(0, cusum_neg - z_normalized - cusum_drift);
    
    cusum_current = max(cusum_pos, cusum_neg);
    cusum_stat(k) = cusum_current;
    
    if cusum_current > cusum_threshold
        fault_cusum(k) = 1;
    end
    
    %% 7-BIT QUANTIZATION OF ALL 4 SIGNALS
    s1 = quantize_7bit(theta_diff(k), ranges.theta);
    s2 = quantize_7bit(q_air(k), ranges.q);
    s3 = quantize_7bit(u_air(k), ranges.u);
    s4 = quantize_7bit(w_air(k), ranges.w);
    
    signal1_quant(k) = s1;
    signal2_quant(k) = s2;
    signal3_quant(k) = s3;
    signal4_quant(k) = s4;
    
    % 4-BIT STATUS FLAGS
    flag_k_spike = (K_norm(k) > 1.5*K_baseline);
    flag_chi2 = fault_chi2(k);
    flag_cusum = fault_cusum(k);
    flag_innov = (abs(z_normalized) > 2.5);
    
    flags = calc_flags(flag_k_spike, flag_chi2, flag_cusum, flag_innov);
    status_flags(k) = flags;
    
    % PACK INTO 32-BIT INTEGER
    % Layout: [s1(7) | s2(7) | s3(7) | s4(7) | flags(4)]
    packed = uint32(s1) + bitshift(uint32(s2),7) + bitshift(uint32(s3),14) + ...
             bitshift(uint32(s4),21) + bitshift(uint32(flags),28);
    
    packed_int(k) = double(packed);
    
    % UNPACK
    s1_rx = double(bitand(packed, uint32(127)));
    s2_rx = double(bitand(bitshift(packed,-7), uint32(127)));
    s3_rx = double(bitand(bitshift(packed,-14), uint32(127)));
    s4_rx = double(bitand(bitshift(packed,-21), uint32(127)));
    flags_rx = double(bitand(bitshift(packed,-28), uint32(15)));
    
    % DEQUANTIZE
    theta_after_unpack(k) = dequantize_7bit(s1_rx, ranges.theta);
    
    % Print detailed info every 200 samples
    if mod(k, 200) == 0
        fprintf('\n=== t=%.1fs (sample %d) ===\n', t(k), k);
        fprintf('ORIGINAL SIGNALS:\n');
        fprintf('  theta_diff = %.4f rad\n', theta_diff(k));
        fprintf('  q = %.4f rad/s\n', q_air(k));
        fprintf('  u = %.4f m/s\n', u_air(k));
        fprintf('  w = %.4f m/s\n', w_air(k));
        fprintf('\n7-BIT QUANTIZED:\n');
        fprintf('  s1(theta) = %3d  binary: %s\n', s1, dec2bin(s1,7));
        fprintf('  s2(q)     = %3d  binary: %s\n', s2, dec2bin(s2,7));
        fprintf('  s3(u)     = %3d  binary: %s\n', s3, dec2bin(s3,7));
        fprintf('  s4(w)     = %3d  binary: %s\n', s4, dec2bin(s4,7));
        fprintf('\n4-BIT STATUS FLAGS:\n');
        fprintf('  Flags = %d  binary: %s\n', flags, dec2bin(flags,4));
        fprintf('  [K_spike=%d, Chi2=%d, CUSUM=%d, Innov=%d]\n', ...
            flag_k_spike, flag_chi2, flag_cusum, flag_innov);
        fprintf('\nPACKED 32-BIT INTEGER:\n');
        fprintf('  Decimal: %u\n', packed);
        fprintf('  Binary:  %s\n', dec2bin(packed,32));
        fprintf('\nAFTER UNPACKING:\n');
        fprintf('  theta_reconstructed = %.4f rad\n', theta_after_unpack(k));
        fprintf('  Quantization error = %.6f rad\n', theta_diff(k)-theta_after_unpack(k));
    end
end

fprintf('\n\nSimulation Complete!\n\n');

%% ========================================================================
%  RESULTS
%% ========================================================================

ground_truth = zeros(1,N);
ground_truth(fault_start:fault_end) = 1;

tp_chi2 = sum(fault_chi2 & ground_truth);
fp_chi2 = sum(fault_chi2 & ~ground_truth);
tp_cusum = sum(fault_cusum & ground_truth);
fp_cusum = sum(fault_cusum & ~ground_truth);

quant_error = theta_diff - theta_after_unpack;
rmse_quant = sqrt(mean(quant_error.^2));

fprintf('================================================================\n');
fprintf('FINAL RESULTS\n');
fprintf('================================================================\n\n');

fprintf('FAULT DETECTION PERFORMANCE:\n');
fprintf('  Chi-Squared: TP=%d, FP=%d, Detection Rate=%.1f%%\n', ...
    tp_chi2, fp_chi2, tp_chi2/sum(ground_truth)*100);
fprintf('  CUSUM:       TP=%d, FP=%d, Detection Rate=%.1f%%\n\n', ...
    tp_cusum, fp_cusum, tp_cusum/sum(ground_truth)*100);

fprintf('KALMAN GAIN ANALYSIS:\n');
fprintf('  Baseline (normal): %.4f\n', K_baseline);
fprintf('  Maximum (fault):   %.4f\n', max(K_norm));
fprintf('  Spike ratio:       %.2fx\n\n', max(K_norm)/K_baseline);

fprintf('7-BIT QUANTIZATION:\n');
fprintf('  RMSE: %.6f rad (%.3f degrees)\n', rmse_quant, rad2deg(rmse_quant));
fprintf('  Max error: %.6f rad\n\n', max(abs(quant_error)));

fprintf('EXAMPLE PACKED INTEGERS:\n');
fprintf('  Sample 100 (normal): %u\n', uint32(packed_int(100)));
fprintf('  Sample 700 (FAULT):  %u\n', uint32(packed_int(700)));
fprintf('  Sample 900 (normal): %u\n\n', uint32(packed_int(900)));

%% ========================================================================
%  CLEAR, MEANINGFUL PLOTS
%% ========================================================================

figure('Position',[50 50 1800 1000]);

% 1. IN-AIR MODEL
subplot(3,3,1);
plot(t, theta_air_meas, 'b.', 'MarkerSize', 2); hold on;
plot(t, theta_air_est, 'r-', 'LineWidth', 2);
xline(fault_start*Ts, 'k--', 'LineWidth', 2);
xline(fault_end*Ts, 'k--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Theta (rad)');
title('IN-AIR MODEL (with fault)');
legend('Measured', 'Kalman Est', 'Location', 'best');
grid on;

% 2. GROUND MODEL
subplot(3,3,2);
plot(t, theta_gnd_est, 'g-', 'LineWidth', 2); hold on;
xline(fault_start*Ts, 'k--', 'LineWidth', 2);
xline(fault_end*Ts, 'k--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Theta (rad)');
title('ON-GROUND MODEL (clean reference)');
grid on;

% 3. DIFFERENCE
subplot(3,3,3);
plot(t, theta_diff, 'b-', 'LineWidth', 2); hold on;
xline(fault_start*Ts, 'r--', 'LineWidth', 3);
xline(fault_end*Ts, 'r--', 'LineWidth', 3);
xlabel('Time (s)'); ylabel('Difference (rad)');
title('DIFFERENCE = Fault Signal');
grid on;

% 4. KALMAN GAIN (SHOULD SPIKE!)
subplot(3,3,4);
plot(t, K_norm, 'b-', 'LineWidth', 2); hold on;
yline(K_baseline, 'g--', 'LineWidth', 1.5, 'DisplayName', 'Baseline');
xline(fault_start*Ts, 'r--', 'LineWidth', 2);
xline(fault_end*Ts, 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('||K||');
title('KALMAN GAIN (watch the spike!)');
legend('K(t)', 'Baseline', 'Location', 'best');
grid on;

% 5. CHI-SQUARED
subplot(3,3,5);
plot(t, chi2_stat, 'b-', 'LineWidth', 1.5); hold on;
yline(chi2_threshold, 'r--', 'LineWidth', 2);
xline(fault_start*Ts, 'k--');
xline(fault_end*Ts, 'k--');
xlabel('Time (s)'); ylabel('Statistic');
title(sprintf('CHI-SQUARED (Detections: %d)', sum(fault_chi2)));
legend('Statistic', 'Threshold', 'Location', 'best');
grid on;

% 6. CUSUM
subplot(3,3,6);
plot(t, cusum_stat, 'b-', 'LineWidth', 1.5); hold on;
yline(cusum_threshold, 'r--', 'LineWidth', 2);
xline(fault_start*Ts, 'k--');
xline(fault_end*Ts, 'k--');
xlabel('Time (s)'); ylabel('Statistic');
title(sprintf('CUSUM (Detections: %d)', sum(fault_cusum)));
legend('Statistic', 'Threshold', 'Location', 'best');
grid on;

% 7. 7-BIT QUANTIZATION ERROR
subplot(3,3,7);
plot(t, quant_error*1000, 'r-', 'LineWidth', 1);
xlabel('Time (s)'); ylabel('Error (mrad)');
title(sprintf('Quantization Error (RMSE=%.3f mrad)', rmse_quant*1000));
grid on;

% 8. ALL 4 QUANTIZED SIGNALS
subplot(3,3,8);
plot(t, signal1_quant, 'b-'); hold on;
plot(t, signal2_quant, 'r-');
plot(t, signal3_quant, 'g-');
plot(t, signal4_quant, 'm-');
xlabel('Time (s)'); ylabel('Quantized Value (0-127)');
title('All 4 Signals After 7-bit Quantization');
legend('theta', 'q', 'u', 'w', 'Location', 'best');
grid on;

% 9. STATUS FLAGS
subplot(3,3,9);
plot(t, status_flags, 'k-', 'LineWidth', 1.5); hold on;
xline(fault_start*Ts, 'r--', 'LineWidth', 2);
xline(fault_end*Ts, 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('4-bit Flag Value (0-15)');
title('STATUS FLAGS (K_spike|Chi2|CUSUM|Innov)');
grid on;

fprintf('================================================================\n');
fprintf('ALL DONE - COMPLETE WORKING SYSTEM\n');
fprintf('================================================================\n');