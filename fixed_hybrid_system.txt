clear; clc; close all;

fprintf('================================================================\n');
fprintf('HYBRID KALMAN FILTER SYSTEM\n');
fprintf('Continuous Kalman-Bucy for Model + Discrete for Sensors\n');
fprintf('================================================================\n\n');

%% ========================================================================
%  AIRCRAFT MODEL (MIT OCW Based)
%% ========================================================================

A = [-0.045  0.036   0      -9.81;
      0.369  -2.02   50     0;
      0.191  -3.96   -2.98  0;
      0      0       1      0];

B = [-0.003;
     -0.76;
     -8.67;
      0];

C = [0 0 0 1];  % Measure theta

Ts = 0.01;
Ad = expm(A*Ts);
Bd = (A\(Ad - eye(4)))*B;
Cd = C;

fprintf('Aircraft Model: 4 states [u, w, q, theta]\n');
fprintf('Sampling: 100 Hz\n\n');

%% ========================================================================
%  SIMULATION SETUP
%% ========================================================================

t_end = 10;
t = 0:Ts:t_end;
N = length(t);

% CONTROL INPUT: Large doublet to see clear response
u_control = zeros(1,N);
u_control(100:300) = 5*pi/180;    % +5 deg, t=1-3s
u_control(300:500) = -5*pi/180;   % -5 deg, t=3-5s

% FAULT: t=6-8s (large bias)
fault_start = 600;
fault_end = 800;
fault_mag = 0.5;  % 0.5 rad = 28.6 degrees (VISIBLE!)

Q = eye(4)*0.01;
R = 0.05;

fprintf('Fault injection: t=6-8s, magnitude=%.1f rad (%.1f deg)\n\n', ...
    fault_mag, rad2deg(fault_mag));

%% ========================================================================
%  INITIALIZE TWO MODELS + HYBRID KALMAN
%% ========================================================================

% IN-AIR MODEL (has fault)
x_air_true = [0;0;0;0];
x_air_est_continuous = [0;0;0;0];  % Continuous Kalman-Bucy
P_air_continuous = eye(4)*0.1;
x_air_est_discrete = [0;0;0;0];    % Discrete sensor update
P_air_discrete = eye(4)*0.1;

% ON-GROUND MODEL (reference)
x_gnd_true = [0;0;0;0];
x_gnd_est = [0;0;0;0];
P_gnd = eye(4)*0.1;

% Storage
theta_air_true = zeros(1,N);
theta_air_measured = zeros(1,N);
theta_air_est_hybrid = zeros(1,N);
theta_gnd_est = zeros(1,N);
theta_diff = zeros(1,N);

K_air_norm = zeros(1,N);
K_gnd_norm = zeros(1,N);

chi2_stat = zeros(1,N);
cusum_stat = zeros(1,N);
fault_chi2 = zeros(1,N);
fault_cusum = zeros(1,N);

% Quantization
theta_before_quant = zeros(1,N);
theta_after_quant = zeros(1,N);
packed_integers = zeros(1,N);

% Detection parameters
window_len = 15;
chi2_thresh = 21.666;
resid_window = zeros(1,window_len);
cusum_thresh = 4.0;
cusum_drift = 0.5;
cusum_pos = 0;
cusum_neg = 0;

K_baseline = 0;

fprintf('Starting simulation with HYBRID Kalman...\n\n');

%% ========================================================================
%  MAIN LOOP
%% ========================================================================

for k = 1:N
    
    %% ==================================================================
    %  IN-AIR TRUE DYNAMICS (Runge-Kutta 4 for continuous model)
    %% ==================================================================
    
    % RK4 integration of continuous dynamics
    w_process = sqrtm(Q)*randn(4,1)*sqrt(Ts);
    
    k1 = A*x_air_true + B*u_control(k);
    k2 = A*(x_air_true + 0.5*Ts*k1) + B*u_control(k);
    k3 = A*(x_air_true + 0.5*Ts*k2) + B*u_control(k);
    k4 = A*(x_air_true + Ts*k3) + B*u_control(k);
    
    x_air_true = x_air_true + (Ts/6)*(k1 + 2*k2 + 2*k3 + k4) + w_process;
    
    % True output
    theta_air_true(k) = C*x_air_true;
    
    % SENSOR MEASUREMENT (discrete, from ADC)
    v_sensor = sqrt(R)*randn;
    theta_air_measured(k) = C*x_air_true + v_sensor;
    
    % INJECT FAULT
    if k >= fault_start && k <= fault_end
        theta_air_measured(k) = theta_air_measured(k) + fault_mag;
    end
    
    %% ==================================================================
    %  HYBRID KALMAN FILTER FOR IN-AIR
    %  Step 1: Continuous prediction (Kalman-Bucy)
    %  Step 2: Discrete measurement update
    %% ==================================================================
    
    % CONTINUOUS PREDICTION (Kalman-Bucy ODE integration)
    % dx̂/dt = A*x̂ + B*u
    % dP/dt = A*P + P*A' + Q
    
    % RK4 for state prediction
    k1_est = A*x_air_est_continuous + B*u_control(k);
    k2_est = A*(x_air_est_continuous + 0.5*Ts*k1_est) + B*u_control(k);
    k3_est = A*(x_air_est_continuous + 0.5*Ts*k2_est) + B*u_control(k);
    k4_est = A*(x_air_est_continuous + Ts*k3_est) + B*u_control(k);
    
    x_air_predicted = x_air_est_continuous + (Ts/6)*(k1_est + 2*k2_est + 2*k3_est + k4_est);
    
    % Covariance prediction (Euler integration)
    P_dot = A*P_air_continuous + P_air_continuous*A' + Q;
    P_air_predicted = P_air_continuous + Ts*P_dot;
    
    % DISCRETE MEASUREMENT UPDATE (standard Kalman at sensor rate)
    innovation = theta_air_measured(k) - C*x_air_predicted;
    S = C*P_air_predicted*C' + R;
    K = P_air_predicted*C'/S;
    
    x_air_est_continuous = x_air_predicted + K*innovation;
    P_air_continuous = (eye(4) - K*C)*P_air_predicted;
    
    theta_air_est_hybrid(k) = C*x_air_est_continuous;
    K_air_norm(k) = norm(K);
    
    if k <= 100
        K_baseline = K_baseline + K_air_norm(k)/100;
    end
    
    %% ==================================================================
    %  ON-GROUND REFERENCE (Standard discrete Kalman)
    %% ==================================================================
    
    w_gnd = sqrtm(Q)*randn(4,1)*sqrt(Ts);
    k1_gnd = A*x_gnd_true + B*u_control(k);
    k2_gnd = A*(x_gnd_true + 0.5*Ts*k1_gnd) + B*u_control(k);
    k3_gnd = A*(x_gnd_true + 0.5*Ts*k2_gnd) + B*u_control(k);
    k4_gnd = A*(x_gnd_true + Ts*k3_gnd) + B*u_control(k);
    x_gnd_true = x_gnd_true + (Ts/6)*(k1_gnd + 2*k2_gnd + 2*k3_gnd + k4_gnd) + w_gnd;
    
    v_gnd = sqrt(R)*randn;
    y_gnd = C*x_gnd_true + v_gnd;
    
    % Discrete Kalman
    x_pred_gnd = Ad*x_gnd_est + Bd*u_control(k);
    P_pred_gnd = Ad*P_gnd*Ad' + Q*Ts;
    innov_gnd = y_gnd - C*x_pred_gnd;
    S_gnd = C*P_pred_gnd*C' + R;
    K_gnd = P_pred_gnd*C'/S_gnd;
    x_gnd_est = x_pred_gnd + K_gnd*innov_gnd;
    P_gnd = (eye(4) - K_gnd*C)*P_pred_gnd;
    
    theta_gnd_est(k) = C*x_gnd_est;
    K_gnd_norm(k) = norm(K_gnd);
    
    %% ==================================================================
    %  DIFFERENCE SIGNAL
    %% ==================================================================
    
    theta_diff(k) = theta_air_est_hybrid(k) - theta_gnd_est(k);
    innov_diff = innovation - innov_gnd;
    
    %% ==================================================================
    %  DETECTION
    %% ==================================================================
    
    % Chi-Squared
    resid_norm = innov_diff^2 / (S + S_gnd);
    resid_window = [resid_window(2:end), resid_norm];
    
    if k >= window_len
        chi2 = sum(resid_window);
        chi2_stat(k) = chi2;
        if chi2 > chi2_thresh
            fault_chi2(k) = 1;
        end
    end
    
    % CUSUM
    z = innov_diff / sqrt(S + S_gnd);
    cusum_pos = max(0, cusum_pos + z - cusum_drift);
    cusum_neg = max(0, cusum_neg - z - cusum_drift);
    cusum_stat(k) = max(cusum_pos, cusum_neg);
    
    if cusum_stat(k) > cusum_thresh
        fault_cusum(k) = 1;
        cusum_pos = 0;
        cusum_neg = 0;
    end
    
    %% ==================================================================
    %  7-BIT QUANTIZATION
    %% ==================================================================
    
    theta_before_quant(k) = theta_diff(k);
    
    % Quantize with proper range
    theta_range = [-1.0, 1.0];  % LARGER range to avoid NaN
    
    val_normalized = (theta_diff(k) - theta_range(1)) / (theta_range(2) - theta_range(1));
    s1 = round(val_normalized * 127);
    s1 = max(0, min(127, s1));  % Clamp
    
    % Pack (4 signals × 7 bits)
    s2 = round(rand*127);  % Dummy for demo
    s3 = round(rand*127);
    s4 = round(rand*127);
    
    packed = uint32(s1) + bitshift(uint32(s2),7) + bitshift(uint32(s3),14) + bitshift(uint32(s4),21);
    packed_integers(k) = double(packed);
    
    % Unpack
    s1_rx = double(bitand(packed, uint32(127)));
    theta_after_quant(k) = theta_range(1) + s1_rx*(theta_range(2)-theta_range(1))/127;
    
    if mod(k,200) == 0
        fprintf('t=%.1fs: theta_diff=%.4f, s1=%d, packed=%u, after=%.4f\n', ...
            t(k), theta_diff(k), s1, packed, theta_after_quant(k));
    end
    
end

fprintf('\nSimulation complete\n\n');

%% ========================================================================
%  RESULTS
%% ========================================================================

ground_truth = zeros(1,N);
ground_truth(fault_start:fault_end) = 1;

tp_chi2 = sum(fault_chi2 & ground_truth);
fp_chi2 = sum(fault_chi2 & ~ground_truth);
tp_cusum = sum(fault_cusum & ground_truth);
fp_cusum = sum(fault_cusum & ~ground_truth);

rmse_quant = sqrt(mean((theta_before_quant - theta_after_quant).^2));

fprintf('================================================================\n');
fprintf('RESULTS\n');
fprintf('================================================================\n\n');
fprintf('DETECTION:\n');
fprintf('  Chi-Squared: TP=%d, FP=%d\n', tp_chi2, fp_chi2);
fprintf('  CUSUM:       TP=%d, FP=%d\n\n', tp_cusum, fp_cusum);
fprintf('QUANTIZATION:\n');
fprintf('  RMSE: %.6f rad\n', rmse_quant);
fprintf('KALMAN GAIN:\n');
fprintf('  Baseline: %.4f\n', K_baseline);
fprintf('  Max:      %.4f\n', max(K_air_norm));
fprintf('  Spike:    %.2fx\n\n', max(K_air_norm)/K_baseline);

%% ========================================================================
%  CLEAR PLOTS
%% ========================================================================

figure('Position',[50 50 1800 1000]);

% Plot 1: IN-AIR MODEL (should show CLEAR fault)
subplot(3,3,1);
plot(t, theta_air_true, 'k-', 'LineWidth', 0.5); hold on;
plot(t, theta_air_measured, 'b.', 'MarkerSize', 3);
plot(t, theta_air_est_hybrid, 'r-', 'LineWidth', 2);
plot([fault_start*Ts fault_start*Ts], ylim, 'r--', 'LineWidth', 2);
plot([fault_end*Ts fault_end*Ts], ylim, 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Theta (rad)');
title('IN-AIR MODEL (Hybrid Kalman-Bucy)');
legend('True', 'Measured', 'Estimate', 'Location', 'best');
grid on;

% Plot 2: ON-GROUND MODEL (should be clean)
subplot(3,3,2);
plot(t, theta_gnd_est, 'g-', 'LineWidth', 2); hold on;
plot([fault_start*Ts fault_start*Ts], ylim, 'r--', 'LineWidth', 2);
plot([fault_end*Ts fault_end*Ts], ylim, 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Theta (rad)');
title('ON-GROUND MODEL (Reference)');
grid on;

% Plot 3: DIFFERENCE (should show CLEAR fault)
subplot(3,3,3);
plot(t, theta_diff, 'b-', 'LineWidth', 2); hold on;
plot([fault_start*Ts fault_start*Ts], ylim, 'r--', 'LineWidth', 2);
plot([fault_end*Ts fault_end*Ts], ylim, 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Difference (rad)');
title('DIFFERENCE (Fault Signal)');
grid on;

% Plot 4: KALMAN GAIN (should SPIKE during fault!)
subplot(3,3,4);
plot(t, K_air_norm, 'b-', 'LineWidth', 2); hold on;
plot(t, K_baseline*ones(size(t)), 'g--', 'LineWidth', 1.5);
plot([fault_start*Ts fault_start*Ts], ylim, 'r--', 'LineWidth', 2);
plot([fault_end*Ts fault_end*Ts], ylim, 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('||K||');
title('KALMAN GAIN (Watch Spike!)');
legend('K(t)', 'Baseline', 'Location', 'best');
grid on;

% Plot 5: CHI-SQUARED
subplot(3,3,5);
plot(t, chi2_stat, 'b-', 'LineWidth', 1.5); hold on;
plot(t, chi2_thresh*ones(size(t)), 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Statistic');
title('WINDOWED CHI-SQUARED');
grid on;

% Plot 6: CUSUM
subplot(3,3,6);
plot(t, cusum_stat, 'b-', 'LineWidth', 1.5); hold on;
plot(t, cusum_thresh*ones(size(t)), 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Statistic');
title('CUSUM');
grid on;

% Plot 7: QUANTIZATION
subplot(3,3,7);
plot(t, theta_before_quant, 'b-', 'LineWidth', 1.5); hold on;
plot(t, theta_after_quant, 'r-', 'LineWidth', 1);
xlabel('Time (s)'); ylabel('Theta (rad)');
title(sprintf('7-bit Quantization (RMSE=%.4f)', rmse_quant));
legend('Before', 'After', 'Location', 'best');
grid on;

% Plot 8: K-GAIN ZOOM
idx_zoom = max(1,fault_start-100):min(N,fault_end+200);
subplot(3,3,8);
plot(t(idx_zoom), K_air_norm(idx_zoom), 'b-', 'LineWidth', 2); hold on;
plot([fault_start*Ts fault_start*Ts], ylim, 'r--', 'LineWidth', 2);
plot([fault_end*Ts fault_end*Ts], ylim, 'r--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('||K||');
title('K-GAIN ZOOMED (Spike→Settle)');
grid on;

% Plot 9: ALL TOGETHER
subplot(3,3,9);
plot(t, theta_air_est_hybrid, 'b-', 'LineWidth', 1.5); hold on;
plot(t, theta_gnd_est, 'g-', 'LineWidth', 1.5);
plot(t, theta_diff, 'r-', 'LineWidth', 2);
plot([fault_start*Ts fault_start*Ts], ylim, 'k--', 'LineWidth', 2);
plot([fault_end*Ts fault_end*Ts], ylim, 'k--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Theta (rad)');
title('ALL SIGNALS');
legend('In-Air', 'Ground', 'Difference', 'Location', 'best');
grid on;

fprintf('================================================================\n');
fprintf('HYBRID KALMAN SYSTEM COMPLETE\n');
fprintf('================================================================\n');